### 21. 合并两个有序链表

将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例：

输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/merge-two-sorted-lists
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 思路

老问题了，递归解决，设置一个返回值然后给子任务。

### 代码

```cpp
class Solution {
public:
    //递归实现
    //小的值先处理，剩下的丢给子任务
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(l1==NULL)
            return l2;
        if(l2==NULL)
            return l1;
        ListNode *ret=NULL;
        if(l1->val > l2->val)
        {
            ret = l2;
            ret->next = mergeTwoLists(l1,l2->next);

        }else
        {
            ret = l1;
            ret->next = mergeTwoLists(l1->next,l2);
        }
        return ret;
    }
};
```

### 148. 排序链表

在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。

示例 1:

输入: 4->2->1->3
输出: 1->2->3->4
示例 2:

输入: -1->5->3->4->0
输出: -1->0->3->4->5

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/sort-list
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 思路

大佬思路

[c++] 归并排序。

由于题目要求空间复杂度是 O(1)，因此不能使用递归。因此这里使用 bottom-to-up 的算法来解决。

太晚了，明天讲解！

ok，归来！

bottom-to-up 的归并思路是这样的：先两个两个的 merge，完成一趟后，再 4 个4个的 merge，直到结束。举个简单的例子：`[4,3,1,7,8,9,2,11,5,6]`.

```angelscript
step=1: (3->4)->(1->7)->(8->9)->(2->11)->(5->6)
step=2: (1->3->4->7)->(2->8->9->11)->(5->6)
step=4: (1->2->3->4->7->8->9->11)->5->6
step=8: (1->2->3->4->5->6->7->8->9->11)
```

链表里操作最难掌握的应该就是各种断链啊，然后再挂接啊。在这里，我们主要用到链表操作的两个技术：

- `merge(l1, l2)`，双路归并，我相信这个操作大家已经非常熟练的，就不做介绍了。
- `cut(l, n)`，可能有些同学没有听说过，它其实就是一种 split 操作，即断链操作。不过我感觉使用 cut 更准确一些，它表示，将链表 `l` 切掉前 n 个节点，并返回后半部分的链表头。
- 额外再补充一个 dummyHead 大法，已经讲过无数次了，仔细体会吧。

```cpp
current = dummy.next;
tail = dummy;
for (step = 1; step < length; step *= 2) {
	while (current) {
		// left->@->@->@->@->@->@->null
		left = current;

		// left->@->@->null   right->@->@->@->@->null
		right = cut(current, step); // 将 current 切掉前 step 个头切下来。

		// left->@->@->null   right->@->@->null   current->@->@->null
		current = cut(right, step); // 将 right 切掉前 step 个头切下来。
		
		// dummy.next -> @->@->@->@->null，最后一个节点是 tail，始终记录
		//                        ^
		//                        tail
		tail.next = merge(left, right);
		while (tail->next) tail = tail->next; // 保持 tail 为尾部
	}
}
```

希望同学们能把双路归并和 cut 断链的代码烂记于心，以后看到类似的题目能够刷到手软。

掌握了这三大神器后，我们的 bottom-to-up 算法伪代码就十分清晰了：

### 代码

```cpp
class Solution {
public:
    //函数 merge l1, l2 

    //cut (1,n) 断链  链表 切掉前n个 节点，返回后半部分链表头


    ListNode* sortList(ListNode* head) {
        //归并排序
        ListNode dummyHead(0);
        dummyHead.next = head;
        auto p = head;
        int length = 0;
        while(p)
        {
            ++length;
            p = p->next;
        }

        for(int size=1;size<length;size<<=1)
        {
            auto cur = dummyHead.next;
            auto tail = &dummyHead;
            while(cur)
            {
                auto left = cur; 
                auto right = cut(left,size); // left->@->@ right->@->@->@...
                cur = cut(right,size); // left->@->@ right->@->@  cur->@->...
                tail->next = merge(left,right);
                while(tail->next)
                {
                    tail = tail->next;
                }
            }
        }
        return dummyHead.next;

    }

    ListNode *cut(ListNode*head,int n)
    {
        auto p = head;
        while(--n&&p)
        {
            p = p->next;
        }
        if(!p)
            return nullptr;
        auto next = p->next;
        p->next = NULL;
        return next;
    }

    ListNode* merge(ListNode* l1, ListNode* l2) {
        if(l1==NULL)
            return l2;
        if(l2==NULL)
            return l1;
        ListNode *ret=NULL;
        if(l1->val > l2->val)
        {
            ret = l2;
            ret->next = merge(l1,l2->next);

        }else
        {
            ret = l1;
            ret->next = merge(l1->next,l2);
        }
        return ret;
    }
    
};
```

