// @File   : 32_longestValidParentheses.cpp
// @Source : https://leetcode-cn.com/problems/longest-valid-parentheses/
// @Title  : 32. 最长有效括号
// @Auther : sun_ds
// @Date   : 2020/5/12

/**  题目描述：
    给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

    示例 1:

    输入: "(()"
    输出: 2
    解释: 最长有效括号子串为 "()"
    示例 2:

    输入: ")()())"
    输出: 4
    解释: 最长有效括号子串为 "()()"

    来源：力扣（LeetCode）
    链接：https://leetcode-cn.com/problems/longest-valid-parentheses
    著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

/**
 *
 * 1.栈
 * 栈中存储各个括号的索引(方便计算长度)
 * 栈底始终存着一个')',作为合法括号起点的前一个位置。(初始化时，先入栈一个-1)。
 *  1.1 当前元素为'('时，直接入栈该元素的索引。
 *  1.2 当前元素为')'时，需要分情况讨论。
 *      先使栈出栈栈顶元素。
 *      1.2.1 若栈非空 说明出栈的是'(' 因为栈中只有栈底有一个打头的'('
 *            由于有效的括号都被消消乐出栈了，所以此时栈顶的值为当前i位置能够组成的有效括号的前一个位置。(此时栈顶可能是未被匹配的'('，也可能是打头的')',这都不影响)
 *            所以，此时有效括号长度为 i - stack.top(). 使用res记录过程中最大的有效括号长度。
 *      1.2.2 若栈空了，说明出栈的是栈中唯一的打头的')'
 *            此时，需要将当前这个')'的索引入栈，变成新的打头的位置。
 * 最终得到最大有效括号长度 res
 *
 *  时间复杂度O(N)
 *  空间复杂度O(N)
 *
 * 2.dp
 *  dp[i]表示以i结尾的最长有效括号。必须包含i位置元素。
 *  2.1 若s[i] == '('
 *      dp[i] = 0;
 *  原因:s[i] == '(' 对于有效括号长度没有任何贡献，即还是dp[i-1]
 *      但是不能是 dp[i] = dp[i-1].
 *      因为不但没有贡献，还有副作用，即切断了前后有效括号的连续性。所以应该置为0.切断前后。
 *      不然，另dp[i] = dp[i-1].相当于删除了i位置的左括号，为后面提供了便利？。这是不行的。所以用0来隔断。
 *  2.2 若s[i] == ')'
 *      需要判断前面的元素
 *      2.2.1 若s[i-1] == '('
 *          dp[i] = dp[i-2] + 2;
 *      2.2.2 若s[i-1] == ')'
 *          dp[i] = dp[i-1] + dp[i - dp[i-1] - 2] + 2;
 *
 *  实现时需要判断各个索引是否在有效范围内。见程序处注释。
 *
 *  时间复杂度O(N)
 *  空间复杂度O(N)
 *
 * 3.计数法
 *  使用l和r记录遍历过程中左右括号出现的次数。
 *  从左往右遍历。
 *  若l>r,没什么问题,继续遍历。(因为左括号多于右括号，只有后面有右括号就可以补救)
 *  若l==r,则说明括号匹配了。当前有效括号长度为l+r。res始终记录遍历过程中最长括号。
 *  若l<r,有问题,以当前位置结尾的子段肯定不是有效括号(因为右括号多于左括号了，没办法补救了) 将l和r清零，重新开始。 l=r=0;
 *  只有从左往右遍历，不能够覆盖所有情况。考虑(((()) 和 (())))。 (((())中l一直大于r，不能记录有效括号长度，需要从右往左遍历。
 *  从右往左遍历，类似。即置零的条件变为r>l。
 *
 *  最终得到结果res。
 *
 *  时间复杂度O(N)
 *  空间复杂度O(1)
 *
 *
 *
 */



//栈
class Solution {
public:
    int longestValidParentheses(string s) {
        int res = 0;
        stack<int> st
        st.push(-1);
        for(int i=0;i<s.size();i++){
            if(s[i]=='('){
                st.push(i);
            }else if(s[i]==')'){
                st.pop();
                if(!st.empty()){
                    res = max(res,i - st.top());
                }else{
                    //新的起点 不符合的
                    st.push(i);
                }
            }
        }
        return res;
    }
};

//dp
class Solution {
public:
    int longestValidParentheses(string s) {
        int n = s.size();
        int res = 0;
        vector<int> dp(n,0);
        for(int i=1;i<n;i++){
            if(s[i]==')'){ //'('不需要处理，直接就是初始化时的0
                if(s[i-1]=='('){
                    //i-1的'（'刚好匹配，则当前有效的括号长度 = i-1前面有效长度 + 2.
                    if(i-2>=0){
                        dp[i] = dp[i-2] + 2;
                    }else{
                        dp[i] = 2;
                    }
                }else if(s[i-1]==')'){
                    //dp[i-1]>0才行，不然dp[i-1]都不能组成有效括号，不能跨越i-1匹配前面的括号 另一方面，dp[i-1]不大于0，必为0，根据公式i-dp[i-1]-1，还是它本身，没必要判断了。
                    if(dp[i-1]>0){
                        //i-1位置匹配了有效括号了，i想要匹配需要在i-1有效括号子段的前面匹配一个’(‘才行。
                        //i-1有效括号子段的前面位置为i-dp[i-1]-1.
                        if((i-dp[i-1]-1 >= 0)&&(s[i-dp[i-1]-1] == '(')){
                            //跳过i-1的有效括号子段，匹配成功。类似上面情况，直接匹配。 dp[i] = dp[i-dp[i-1]-2] + 2.
                            //除此之外还要加上中间跳过的i-1的有效括号子段长度dp[i-1]
                            if(i-dp[i-1]-2>=0){
                                dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2;
                            }else{
                                dp[i] = dp[i-1] + 2;
                            }
                        }
                    }
                }
            }
            //记录过程中的最大值
            res = max(res,dp[i]);
        }
        return res;
    }
};

//计数法
class Solution {
public:
    int longestValidParentheses(string s) {
        int n = s.size();
        int res = 0;
        int l = 0, r = 0;
        for(int i=0;i<n;i++){
            if(s[i]=='('){
                l++;
            }else if(s[i]==')'){
                r++;
            }
            if(l == r) res = max(res,l+r);
            if(r>l) l=0,r=0;
        }
        l = 0, r = 0;
        for(int i=n-1;i>=0;i--){
            if(s[i]=='('){
                l++;
            }else if(s[i]==')'){
                r++;
            }
            if(l == r) res = max(res,l+r);
            if(l>r) l=0,r=0;
        }
        return res;
    }
};

