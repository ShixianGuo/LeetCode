
|Leetcode链表专题|题目|题解|
|-------|----|----|
||19.删除第N个结点|快慢指针，快指针先走n步，然后慢指针开始走，当快指针到达最后一个结点时，慢指针刚好到达倒数第n+1个节点，头结点可能被删除，所以需要创立哑结点|
||237.删除链表中给定结点|将下一个节点复制到当前节点，然后删除下一个节点|
||83.从排序链表中删除节点，只保留一个|判断当前节点是否与下一个节点相同，若相同删除下一个节点，不相同则将当前节点下移|
||61.旋转链表|第一步快慢指针，找到倒数第k+1个结点；第二步将尾结点指向头结点，更新头结点为倒数第k个结点，然后将倒数第k+1个结点->next=nullptr;第三步将新头结点head返回|
||24.交换所有相邻结点|因为头结点可能会改变所以创立了哑结点；循环起始条件为所要交换的前一个结点p,要交换的第一个结点a,要交换的第二个结点b；第二步p->next=b，a->next=b->next,b->next=a,p=a;第三步返回哑结点的->next|
||206.反转链表|从第二个结点开始，记录当前结点下一个结点，修改当前节点next为前一个节点，更新前一个节点为当前节点，更新当前节点为下一个节点；循环结束后，修改头结点->next=nullptr,避免形成环。|
||92.反转链表II|添加哑结点，然后分别走m-1与n步，得到要反转链表的前一个节点与最后一个结点，对其中链表进行反转，反转完成后，将前一个链表的next改为反转后链表部分的头，将原反转部分的头指向之前反转部分的下一个结点|
||110.求单链表的交点|解法1：先遍历得到两链表长度，然后长链表先走，然后两链表同时走，相同时即为交点。解法2：两链表同时走，走过相同路程则一定同时到达交点处(a(A链表不相交部分长度)+b(B链表不相交部分长度)+c(链表相交部分长度))。则从当前链表头开始走，若为nullptr,则赋为另一个链表头，当两指针相同时，return|
||142.链表入环点|快慢指针，快指针一次两步，慢指针一次一步，两指针相等后，快指针回到head,然后两指针一次一步，再次相等时，即为入环点。|
||148.链表排序| |
||25.k个一组翻转链表| |
||21.合并两个有序链表| |

|Leetcode树专题|题目|题解|
|--|--|--|
|M|98.有效的搜索二叉树|解法一，中序遍历，判断是否为递增序列。解法二，给定每一个结点的范围，判断其是否满足范围|
|M|94.二叉树的中序遍历|利用栈，从根节点开始，左子树依此进栈，然后弹出栈顶原始，压入到输出栈，并从栈顶元素的右子树继续进栈|
|E|101.镜像二叉树|判断是否为镜像二叉树，空树也为镜像二叉树(left->val==right->val)&&dfs(left->left,right->right)&&dfs(left->right,right->left)|
|E|27.二叉树的镜像|遍历二叉树，对每一个结点交换其左右树|
|M|105.构造二叉树|通过hash来记录先序结点值在中序vector中的位置，以此判断出左子树与右子树区间，以此递归，生成左右子树|
|M|102.层序遍历|层序遍历，利用queue,通过queue.size()得到每一层的节点个数|
|M|236.二叉树的公共祖先|遇到空则返回空，遇到q则返回q，遇到p则返回p。分别判断左右子树返回值，如果左为空则右边为祖先，若右为空则左边为祖先，若左右都不为空，则两节点分别在左右两边，即根节点为祖先。|
|E|543.二叉树的直径|相当于求左右子树高度和最大值|
|H|124.求权值最大路径|与上题类似，定义一个全局变量用于存储当前路径最大值，分别dfs左右子树得到左右子树最大值，以此更新路径长度，dfs返回当前左右路径中最大值，注意可能有负数，需要和0做比较。|
|M|173.二叉树搜索迭代器|中序遍历即可。|
|H|297.序列化二叉树|类似先序遍历，序列化，将字符串传引用；反序列化，将字符串当前位置记录。|

|Leetcode字符串专题|题目|题解|
|--| -- |--|
|E|38.外观数列|while(i<s.size()&&s[i]==s[j]) i++;|
|M|49.字母异位词分组|利用hash表，字符串排序后作为key，遍历即可|
|M|151.反转字符串|先反转，单独字符串，拼接到一起再反转整个字符串|
|M|165.比较版本号|以.为分隔符，将字符进行分隔，利用atoi提取出对应数字，比较大小。|
||929.相同的邮箱地址|先利用find函数，找到@位置，然后遍历@之前的字符串，遇到+直接break,否则遇到除'.'之外的字符进行拼接。|
||5.最长的回文子串|中心扩展法：确定一个中点，向两边进行扩展，注意奇偶字符串的存在，所以需要遍历两遍字符串，abcba，第一遍，两个起点相同，第二遍两个起点不同，i,i+1|
||6.Z字形变换|寻找规律，序号为等差数列，对于第一行与最后一行，为等差数列，首项为i,其公差为2*(n-1);对于中间行，有两个等差数列，首项为i或2*(n-1)-i|
||3.最长不重复子串|利用两个位置，记录起点与终点，用hash表记录当前字符出现的次数，若终点字符出现的次数超过1，则将起点后移。|
||208.字典树|实现三个函数，构造、判断前缀、判断当前字符串。树中结点由struct Node{bool is_end,Node* son[26]};构成|
||273.数字到英语单词|按照每1000，对数字分割，先添加最大的单位(billion,million,thousand)，然后对表示该单位的1~999进行分隔处理，按照英文单词的特点，对>100，>20特殊处理，添加完当前单词后可以进行取模操作%，判断剩余数字。|
|Leetcode字符串常用函数|||
||substr.find.atoi.| |
||substr|s.substr(pos,n),从pos开始的n个字符，默认n为整个字符长度。 |
||find|s.find(c),返回c在s中的下标位置，若不存在则返回s.npos。|
||atoi|将字符串转换为数字，可跳过前缀0，如"0088",atoi("0088")=88。|

|Leetcode DFS+回溯专题|题目|题解|
|--|--|--|
||17.9键字母组合|第一种：枚举，每次对当前字符对应的字符串进行枚举，套三层循环，第一层循环当前数字，第二层循环当前数字对应的字符，第三层循环当之前记录的字符串，然后进行拼接。第二种：dfs回溯，每次对当前字符串第一个元素进行回溯，然后将当前元素对应字符串添加进路径中。|
||79.单词搜索|每次递归上下左右四个方向，注意填回字符。board[i][j]='.';dfs();board[i][j]=num。|
||46.全排列|对每个位置选择放置哪个数，用vector<bool>来记录，当前数是否被放置。|
||47.全排列II|枚举每个数应该放在哪个位置，若出现重复字符，则当前数应该从该重复字符所安放位置的下一位置开始枚举,用vector<bool>记录，当前位置是否被填充。|
||78.子集|利用二进制进行映射 000 001 ...|
||90.子集II|先排序，然后统计当前数字的个数，分别选择0-选择n个，以此进行类推。|
||216.组合数|dfs，每次从当前位置开始向后取下一个数，当满足条件时return。|
||52.N皇后II|解法1：设置三个vector<bool>,分别记录列、正斜线、反斜线三条路的情况。对每一行，以此对每一列进行选择。解法2：只设置一个数组，用于记录每一行皇后所在列的位置，每次放置时，判断当前列是否满足条件：1.之前行未放置过此列、2.对角线也未放置，k为之前行，i-k=fabs(board[k]-j)|
||37.数独|设置三个vector<bool>col[9][9],row[9][9],row[3][3][9],对每个空位置进行放置，然后计算下一位置。若当前位置不可放置，则直接放置下一位置。if(j==9) i++,j=0;if(i==9) return true;|
||473.用木棒拼凑正方形||
  
|Leetcode 双指针+滑动窗口+单调栈+单调队列|题目|题解|
|--|--|--|
||167.两数之和II|双指针|
||88.合并两个有序数组|从尾归并|
||26.删除排序数组中的重复项|k=1;for(int i=1;i<size;i++)if(n[i]!=n[i-1]) n[k++]=n[i]; return k;|
||76.最小覆盖子串|用hash记录匹配串中的字符数量，将其作为当前想覆盖匹配串还需的字符数量，用双指针控制子串长度，尾指针循环向后，每次匹配到一个匹配串中的字符，hash[c]--,当hash[c]==0,代表该字符以及匹配完毕。当头指针所指字符s的hash[s[j]]<0,则可以将头指针向后缩短区间长度，hash[s[j++]]++。|
||32.最长的括号序列|遇'('+1,遇')'-1,当等于0时记录当前长度，然后更新start为下一位。为防止((()出现，需要正反遍历两遍，对字符串进行反转，并且将')'与'('互换。c^=1;|
||155.最小栈|压栈时，压入最小值。|
||84.柱状图中的矩形|单调栈，栈内元素从小到大排序，利用单调栈求得当前柱左右两边距离最近的比它小的柱形，最后再遍历一遍计算结果，(right-left-1)* height|
||42.接雨水|利用单调栈，栈内由顶至底，从大到小，当大值入栈时，小值以此弹出并且计算大值与当前弹出小值之间的面积，通过与上一个弹出值之间的差得到面积的宽，当前位置与弹出位置之间的距离为长度，res=(height[i]-height[s.top()])* (i-s.top()-1),得到面积。|
||229.滑动窗口最大值|deque实现单调队列，队首元素为当前滑动窗口最大值，每次入栈时，先判断，队首元素是否超过窗口长度，若超过直接pop_front()。并将队中比当前数小的数依次从尾弹出。|
||918.环形子数组的最大和|将环形子数组展开成两倍长度的数组，子数组最大和可以看成为两个前缀和相减，即可将问题转换为，求滑动窗口最小值，滑动窗口内的值代表该位置的前缀和。对每个位置，求其前面滑动窗口内的最小值，子数组和即为当前位置前缀和-滑动窗口最小值。|

|Leetcode基本数据结构|题目|题解|
|--|--|--|
||1.两数之和|利用hash表，遍历一遍即可。hash.count(sum-nums[i]);hash[nums[i]]=i;|
||187.基因序列|利用hash记录所有子串，for(int i=0;i+10<=len;i++),hash[str]++;if(hash[str]==2)res.push_back(str)|
||706.设计哈希表|用vector实现,vector<list<pair<int,int>>>,最重要的是实现一个find方法，返回迭代器。其余put,get,remove方法都基于find方法实现。|
||652.寻找重复子树|利用hash记录每个子树，类似于树的序列化。|
||560.和为k的子数组|子数组的和为,sum[j]-sum[i]。前缀和+hash,遍历依次求得前缀和,在遍历新节点j时,前面位置i的前缀和都已经计算得到，res+=hash[sum-k],hash[sum]++。|
||547.并查集||
||684.求出树中多余的边||
||692.出现次数最多的k个单词|利用hash与堆,hash记录每个字符串出现的次数,利用最大堆来维护出现的次数(对次数取反,这样堆顶即为出现次数最小的单词),其可以保证字典序|
||295.中位数|建立两个堆，最大堆和最小堆，第一个数放入最小堆，接下来，小于最小堆堆顶的压入最大堆，并将最大堆堆顶弹出，压入最小堆，判断最小堆大小-最大堆大小，当差值大于1，最小堆弹出堆顶压入最大堆，求中位数，判断当前数字个数的奇偶，为奇数则取最小堆，为偶数取最大堆。|
||352.区间合并|利用hash记录，每个数的左边界与右边界，当新数字x到达后，找到大于x的最小位置，判断该位置的左边界，若小于x则直接返回，判断数字x-1是否拥有左边界，数字x+1是否拥有右边界，若都拥有，则将R[L[x-1]]=R[x+1],L[R[x+1]]=L[x-1],并删除x-1与x+1边界;若只存在左边界x-1，R[L[x-1]]=x,L[x]=L[x-1],删除x-1;若只存在右边界x+1,L[R[x+1]]=x,R[x+1]=R[x],删除x+1。|
